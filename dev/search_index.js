var documenterSearchIndex = {"docs":
[{"location":"#CodecLz4","page":"Home","title":"CodecLz4","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"(Image: Stable) (Image: Latest) (Image: Build Status) (Image: CodeCov)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [CodecLz4]","category":"page"},{"location":"#CodecLz4.LZ4FastCompressor-Tuple{}","page":"Home","title":"CodecLz4.LZ4FastCompressor","text":"LZ4FastCompressor(; kwargs...)\n\nCreates an LZ4 compression codec.\n\nKeywords\n\nacceleration::Integer=0: acceleration factor\nblock_size::Integer=1024: The size in bytes to encrypt into each block.\n\n\n\n\n\n","category":"method"},{"location":"#CodecLz4.LZ4FastCompressorStream-Tuple{IO}","page":"Home","title":"CodecLz4.LZ4FastCompressorStream","text":"LZ4FastCompressor(stream::IO; kwargs...)\n\nCreates an LZ4 compression stream. See LZ4FastCompressor() and TranscodingStream() for arguments.\n\n\n\n\n\n","category":"method"},{"location":"#CodecLz4.LZ4FrameCompressor-Tuple{}","page":"Home","title":"CodecLz4.LZ4FrameCompressor","text":"LZ4FrameCompressor(; kwargs...)\n\nCreates an LZ4 compression codec.\n\nKeywords\n\nblocksizeid::BlockSizeID=default_size: max64KB, max256KB, max1MB, or max4MB or default_size\nblockmode::BlockMode=block_linked:  block_linked or block_independent\ncontentchecksum::Bool=false: if true, frame is terminated with a   32-bits checksum of decompressed data\nframetype::FrameType=normal_frame):  normal_frame or skippable_frame\ncontentsize::Integer=0: Size of uncompressed content (0 for unknown)\nblockchecksum::Bool=false: if true, each block is followed by a   checksum of block's compressed data\ncompressionlevel::Integer=0: compression level (-1..12)\nautoflush::Bool=false: always flush if true\n\n\n\n\n\n","category":"method"},{"location":"#CodecLz4.LZ4FrameCompressorStream-Tuple{IO}","page":"Home","title":"CodecLz4.LZ4FrameCompressorStream","text":"LZ4FrameCompressorStream(stream::IO; kwargs...)\n\nCreates an LZ4 compression stream. See LZ4FrameCompressor() and TranscodingStream() for arguments.\n\n\n\n\n\n","category":"method"},{"location":"#CodecLz4.LZ4FrameDecompressor-Tuple{}","page":"Home","title":"CodecLz4.LZ4FrameDecompressor","text":"LZ4FrameCompressor()\n\nCreates an LZ4 decompression codec.\n\n\n\n\n\n","category":"method"},{"location":"#CodecLz4.LZ4FrameDecompressorStream-Tuple{IO}","page":"Home","title":"CodecLz4.LZ4FrameDecompressorStream","text":"LZ4FrameCompressorStream(stream::IO; kwargs...)\n\nCreates an LZ4 decompression stream. See TranscodingStream() for arguments.\n\n\n\n\n\n","category":"method"},{"location":"#CodecLz4.LZ4HCCompressor-Tuple{}","page":"Home","title":"CodecLz4.LZ4HCCompressor","text":"LZ4HCCompressor(; kwargs...)\n\nCreates an LZ4 HC compression codec.\n\nKeywords\n\ncompressionlevel::Integer=9: compression level\nblock_size::Integer=1024: The size in bytes to encrypt into each block. (Max 4MB)\n\n\n\n\n\n","category":"method"},{"location":"#CodecLz4.LZ4HCCompressorStream-Tuple{IO}","page":"Home","title":"CodecLz4.LZ4HCCompressorStream","text":"LZ4HCCompressorStream(stream::IO; kwargs...)\n\nCreates an LZ4 HC compression stream. See LZ4HCCompressorStream() and TranscodingStream() for arguments.\n\n\n\n\n\n","category":"method"},{"location":"#CodecLz4.LZ4SafeDecompressor-Tuple{}","page":"Home","title":"CodecLz4.LZ4SafeDecompressor","text":"LZ4SafeDecompressor(; kwargs...)\n\nCreates an LZ4 compression codec.\n\nKeywords\n\nblock_size::Integer=1024: The size in bytes of unecrypted data contained in each block.   Must match or exceed the compression block_size or decompression will fail.\n\n\n\n\n\n","category":"method"},{"location":"#CodecLz4.LZ4SafeDecompressorStream-Tuple{IO}","page":"Home","title":"CodecLz4.LZ4SafeDecompressorStream","text":"LZ4SafeDecompressorStream(stream::IO; kwargs...)\n\nCreates an LZ4 compression stream. See LZ4SafeDecompressor() and TranscodingStream() for arguments.\n\n\n\n\n\n","category":"method"},{"location":"#CodecLz4.LZ4F_compressBegin-Tuple{Ptr{CodecLz4.LZ4F_cctx}, Any, UInt64, Ref{CodecLz4.LZ4F_preferences_t}}","page":"Home","title":"CodecLz4.LZ4F_compressBegin","text":"Will write the frame header into dstBuffer.\n\ndstCapacity must be >= LZ4F_HEADER_SIZE_MAX bytes. prefsPtr is optional : you can provide C_NULL as argument, all preferences will then be set to default. Returns the number of bytes written into dstBuffer for the header or throws an error.\n\n\n\n\n\n","category":"method"},{"location":"#CodecLz4.LZ4F_compressBound-Tuple{UInt64, Ref{CodecLz4.LZ4F_preferences_t}}","page":"Home","title":"CodecLz4.LZ4F_compressBound","text":"Provides minimum dstCapacity for a given srcSize to guarantee operation success in worst case situations.\n\nprefsPtr is optional : when C_NULL is provided, preferences will be set to cover worst case scenario. Result is always the same for a srcSize and prefsPtr, so it can be trusted to size reusable buffers. When srcSize==0, LZ4F_compressBound() provides an upper bound for LZ4F_flush() and LZ4F_compressEnd() operations.\n\n\n\n\n\n","category":"method"},{"location":"#CodecLz4.LZ4F_compressEnd-Tuple{Ptr{CodecLz4.LZ4F_cctx}, Any, UInt64, Any}","page":"Home","title":"CodecLz4.LZ4F_compressEnd","text":"Invoke to properly finish an LZ4 frame.\n\nIt will flush whatever data remained within cctx (like LZ4_flush()) and properly finalize the frame, with an endMark and a checksum. cOptPtr is optional : C_NULL can be provided, in which case all options will be set to default. Returns the number of bytes written into dstBuffer (necessarily >= 4 (endMark), or 8 if optional frame checksum is enabled) or throws an error if it fails (which can be tested using LZ4F_isError()) A successful call to LZ4F_compressEnd() makes cctx available again for another compression task.\n\n\n\n\n\n","category":"method"},{"location":"#CodecLz4.LZ4F_compressUpdate-Tuple{Ptr{CodecLz4.LZ4F_cctx}, Any, UInt64, Any, UInt64, Any}","page":"Home","title":"CodecLz4.LZ4F_compressUpdate","text":"Can be called repetitively to compress as much data as necessary.\n\nAn important rule is that dstCapacity MUST be large enough to ensure operation success even in worst case situations. This value is provided by LZ4F_compressBound(). If this condition is not respected, LZ4F_compress() will fail. LZ4FcompressUpdate() doesn't guarantee error recovery. When an error occurs, compression context must be freed or resized. cOptPtr is optional : `CNULLcan be provided, in which case all options are set to default. Returns the number of bytes written intodstBuffer` (it can be zero, meaning input data was just buffered). or throws an error if it fails.\n\n\n\n\n\n","category":"method"},{"location":"#CodecLz4.LZ4F_createCompressionContext-Tuple{Ref{Ptr{CodecLz4.LZ4F_cctx}}, UInt32}","page":"Home","title":"CodecLz4.LZ4F_createCompressionContext","text":"The first thing to do is to create a compressionContext object, which will be used in all compression operations. This is achieved using LZ4F_createCompressionContext(), which takes as argument a version. The version provided MUST be the current version. It is intended to track potential version mismatch, notably when using DLL. The function will provide a pointer to a fully allocated LZ4F_cctx object. Will throw an error if there was an error during context creation.\n\n\n\n\n\n","category":"method"},{"location":"#CodecLz4.LZ4F_createDecompressionContext-Tuple{Ref{Ptr{CodecLz4.LZ4F_dctx}}, UInt32}","page":"Home","title":"CodecLz4.LZ4F_createDecompressionContext","text":"Create an LZ4F_dctx object, to track all decompression operations.\n\nThe version provided MUST be the current LZ4F version. The function provides a pointer to an allocated and initialized LZ4F_dctx object. The the function throws an error if the LZ4F_dctx object cannot be initialized. The dctx memory can be released using LZ4F_freeDecompressionContext().\n\n\n\n\n\n","category":"method"},{"location":"#CodecLz4.LZ4F_decompress-Tuple{Ptr{CodecLz4.LZ4F_dctx}, Any, Ref{UInt64}, Any, Ref{UInt64}, Any}","page":"Home","title":"CodecLz4.LZ4F_decompress","text":"Call this function repetitively to regenerate compressed data from srcBuffer.\n\nThe function will read up to srcSizePtr bytes from srcBuffer, and decompress data into dstBuffer, of capacity dstSizePtr. The number of bytes consumed from srcBuffer will be written into srcSizePtr (necessarily <= original value). The number of bytes decompressed into dstBuffer will be written into dstSizePtr (necessarily <= original value). The function does not necessarily read all input bytes, so always check value in srcSizePtr. Unconsumed source data must be presented again in subsequent invocations.\n\ndstBuffer can freely change between each consecutive function invocation. dstBuffer content will be overwritten.\n\nReturns an hint of how many srcSize bytes LZ4F_decompress() expects for next call. Schematically, it's the size of the current (or remaining) compressed block + header of next block. Respecting the hint provides some small speed benefit, because it skips intermediate buffers. This is just a hint though, it's always possible to provide any srcSize.\n\nWhen a frame is fully decoded, returns 0 (no more data expected). When provided with more bytes than necessary to decode a frame, LZ4F_decompress() will stop reading exactly at end of current frame, and return 0.\n\nIf decompression failed, an error is thrown. After a decompression error, the dctx context is not resumable. Use LZ4F_resetDecompressionContext() to return to clean state. After a frame is fully decoded, dctx can be used again to decompress another frame.\n\n\n\n\n\n","category":"method"},{"location":"#CodecLz4.LZ4F_flush-Tuple{Ptr{CodecLz4.LZ4F_cctx}, Any, UInt64, Any}","page":"Home","title":"CodecLz4.LZ4F_flush","text":"When data must be generated and sent immediately, without waiting for a block to be completely filled, it's possible to call LZ4_flush(). It will immediately compress any data buffered within cctx. dstCapacity must be large enough to ensure the operation will be successful. cOptPtr is optional : it's possible to provide C_NULL, all options will be set to default. Returns the number of bytes written into dstBuffer (it can be zero, which means there was no data stored within cctx) or throws an error if it fails.\n\n\n\n\n\n","category":"method"},{"location":"#CodecLz4.LZ4F_freeCompressionContext-Tuple{Ptr{CodecLz4.LZ4F_cctx}}","page":"Home","title":"CodecLz4.LZ4F_freeCompressionContext","text":"Releases the memory of a LZ4F_cctx.\n\n\n\n\n\n","category":"method"},{"location":"#CodecLz4.LZ4F_freeDecompressionContext-Tuple{Ptr{CodecLz4.LZ4F_dctx}}","page":"Home","title":"CodecLz4.LZ4F_freeDecompressionContext","text":"Frees the decompressionContext.\n\nThe result of LZ4F_freeDecompressionContext() is indicative of the current state of decompressionContext when being released. That is, it should be == 0 if decompression has been completed fully and correctly.\n\n\n\n\n\n","category":"method"},{"location":"#CodecLz4.LZ4F_getFrameInfo-Tuple{Ptr{CodecLz4.LZ4F_dctx}, Ref{CodecLz4.LZ4F_frameInfo_t}, Any, Any}","page":"Home","title":"CodecLz4.LZ4F_getFrameInfo","text":"Extracts frame parameters (max blockSize, dictID, etc.).\n\nIts usage is optional. Extracted information is typically useful for allocation and dictionary. This function works in 2 situations :\n\nAt the beginning of a new frame, in which case it will decode information from srcBuffer, starting the decoding process. Input size must be large enough to successfully decode the entire frame header. Frame header size is variable, but is guaranteed to be <= LZ4F_HEADER_SIZE_MAX bytes. It's allowed to provide more input data than this minimum.\nAfter decoding has been started. In which case, no input is read, frame parameters are extracted from dctx.\nIf decoding has barely started, but not yet extracted information from header, LZ4F_getFrameInfo() will fail.\n\nThe number of bytes consumed from srcBuffer will be updated within srcSizePtr (necessarily <= original value). Decompression must resume from (srcBuffer + srcSizePtr). Returns an hint about how many srcSize bytes LZ4F_decompress() expects for next call or throws an error.\n\nNote 1 : In case of error, dctx is not modified. Decoding operation can resume from beginning safely. Note 2 : Frame parameters are copied into an already allocated LZ4F_frameInfo_t structure.\n\n\n\n\n\n","category":"method"},{"location":"#CodecLz4.LZ4F_getVersion-Tuple{}","page":"Home","title":"CodecLz4.LZ4F_getVersion","text":"Gets the current LZ4F version.\n\n\n\n\n\n","category":"method"},{"location":"#CodecLz4.LZ4F_resetDecompressionContext-Tuple{Ptr{CodecLz4.LZ4F_dctx}}","page":"Home","title":"CodecLz4.LZ4F_resetDecompressionContext","text":"Re-initializes decompression context\n\nIn case of an error, the context is left in \"undefined\" state. In which case, it's necessary to reset it, before re-using it. This method can also be used to abruptly stop any unfinished decompression, and start a new one using same context resources.\n\n\n\n\n\n","category":"method"},{"location":"#CodecLz4.LZ4_compressBound-Tuple{Any}","page":"Home","title":"CodecLz4.LZ4_compressBound","text":"LZ4_compressBound(inputsize)\n\nProvides the maximum size that LZ4 compression may output in a \"worst case\" scenario (input data not compressible) This function is primarily useful for memory allocation purposes (destination buffer size). Macro LZ4COMPRESSBOUND() is also provided for compilation-time evaluation (stack memory allocation for example). Note that LZ4compressdefault() compress faster when dest buffer size is >= LZ4compressBound(srcsize)     inputsize  : max supported value is LZ4MAXINPUT_SIZE\n\nReturns maximum output size in a \"worst case\" scenario or 0, if input size is too large ( > LZ4MAXINPUT_SIZE)\n\n\n\n\n\n","category":"method"},{"location":"#CodecLz4.LZ4_compress_HC","page":"Home","title":"CodecLz4.LZ4_compress_HC","text":"LZ4_compress_HC(src, dst, srcsize, dstcapacity, compressionlevel)\n\nCompress data from src into dst, using the more powerful but slower \"HC\" algorithm. dst must be already allocated. Compression is guaranteed to succeed if dstcapacity >= LZ4_compressBound(srcsize) Max supported srcsize value is LZ4MAXINPUTSIZE compressionlevel: any value between 1 and LZ4HCCLEVELMAX will work.                     Values > LZ4HCCLEVELMAX behave the same as LZ4HCCLEVEL_MAX. Returns the number of bytes written into dst\n\n\n\n\n\n","category":"function"},{"location":"#CodecLz4.LZ4_compress_HC_continue-Tuple{Ptr{CodecLz4.LZ4_streamHC_t}, Vararg{Any, 4}}","page":"Home","title":"CodecLz4.LZ4_compress_HC_continue","text":"LZ4_compress_HC_continue(streamptr::Ptr{LZ4_streamHC_t}, src, dst, srcsize, maxdstsize)\n\nCompress data in successive blocks of any size, using previous blocks as dictionary. One key assumption is that previous blocks (up to 64 KB) remain read-accessible while compressing next blocks. There is an exception for ring buffers, which can be smaller than 64 KB. Ring buffers scenario is automatically detected and handled by LZ4compressHC_continue().\n\nBefore starting compression, state must be properly initialized, using LZ4_resetStreamHC().\n\nThen, use LZ4compressHCcontinue() to compress each successive block. Previous memory blocks (including initial dictionary when present) must remain accessible and unmodified during compression. dst buffer should be sized to handle worst case scenarios (see LZ4compressBound()), to ensure operation success. Because in case of failure, the API does not guarantee context recovery, and context will have to be reset.\n\n\n\n\n\n","category":"method"},{"location":"#CodecLz4.LZ4_compress_destSize-NTuple{4, Any}","page":"Home","title":"CodecLz4.LZ4_compress_destSize","text":"LZ4_compress_destSize(src, dst, srcsize, dstcapacity)\n\nReverse the logic : compresses as much data as possible from src buffer into already allocated buffer dst of size dstcapacity. This function either compresses the entire src content into dst if it's large enough, or fill dst buffer completely with as much data as possible from src.     *srcsize : will be modified to indicate how many bytes where read from src to fill dst.                   New value is necessarily <= old value.\n\nReturns number of bytes written into dst (necessarily <= dstcapacity)\n\n\n\n\n\n","category":"method"},{"location":"#CodecLz4.LZ4_compress_fast","page":"Home","title":"CodecLz4.LZ4_compress_fast","text":"LZ4_compress_fast(src, dst, srcsize, dstcapacity=1)\n\nCompresses srcsize bytes from buffer src into already allocated dst buffer of size dstcapacity. Compression is guaranteed to succeed if dstcapacity >= LZ4_compressBound(srcsize). It also runs faster, so it's a recommended setting. If the function cannot compress src into a limited dst budget, compression stops immediately, and the function result is zero. As a consequence, dst content is not valid.\n\nAlso allows to select an acceleration factor. The larger the acceleration value, the faster the algorithm, but also the lesser the compression. It's a trade-off. It can be fine tuned, with each successive value providing roughly +~3% to speed. Values <= 0 will be replaced by the default which is 1.\n\nThis function never writes outside dst buffer, nor read outside source buffer.     srcsize : supported max value is LZ4MAXINPUT_VALUE     dstcapacity : full or partial size of buffer dst (which must be already allocated)\n\nReturns the number of bytes written into buffer dst (necessarily <= dstcapacity)\n\n\n\n\n\n","category":"function"},{"location":"#CodecLz4.LZ4_compress_fast_continue","page":"Home","title":"CodecLz4.LZ4_compress_fast_continue","text":"LZ4_compress_fast_continue(streamptr, src, dst, srcsize, dstcapacity, acceleration)\n\nCompress content into src using data from previously compressed blocks, improving compression ratio. dst buffer must be already allocated. If dstcapacity >= LZ4_compressBound(srcsize), compression is guaranteed to succeed, and runs faster.\n\nImportant : Up to 64KB of previously compressed data is assumed to remain present and unmodified in memory ! Special 1 : If input buffer is a double-buffer, it can have any size, including < 64 KB. Special 2 : If input buffer is a ring-buffer, it can have any size, including < 64 KB.\n\nReturns size of compressed block. After an error, the stream status is invalid, it can only be reset or freed.\n\n\n\n\n\n","category":"function"},{"location":"#CodecLz4.LZ4_createStream-Tuple{}","page":"Home","title":"CodecLz4.LZ4_createStream","text":"LZ4_createStream()\n\nWill allocate and initialize an LZ4_stream_t structure.\n\n\n\n\n\n","category":"method"},{"location":"#CodecLz4.LZ4_createStreamDecode-Tuple{}","page":"Home","title":"CodecLz4.LZ4_createStreamDecode","text":"LZ4_createStreamDecode()\n\nThese decoding functions work the same as creation / destruction of streaming decompression tracking structure. A tracking structure can be re-used multiple times sequentially.\n\n\n\n\n\n","category":"method"},{"location":"#CodecLz4.LZ4_createStreamHC-Tuple{}","page":"Home","title":"CodecLz4.LZ4_createStreamHC","text":"LZ4_createStreamHC()\n\nCreate memory for LZ4 HC streaming state. Newly created states are automatically initialized. Existing states can be re-used several times, using LZ4_resetStreamHC().\n\n\n\n\n\n","category":"method"},{"location":"#CodecLz4.LZ4_decompress_safe-NTuple{4, Any}","page":"Home","title":"CodecLz4.LZ4_decompress_safe","text":"LZ4_decompress_safe(src, dst, cmpsize, dstcapacity)\n\nDecompresses cmpsize bytes from buffer src into dst. If destination buffer is not large enough, decoding will stop and output an error. If the source stream is detected malformed, the function will stop decoding and error. This function is protected against buffer overflow exploits, including malicious data packets. It never writes outside output buffer, nor reads outside input buffer.\n\ncmpsize : is the exact complete size of the compressed block. dstcapacity : is the size of destination buffer, which must be already allocated.\n\nReturns the number of bytes decompressed into destination buffer (necessarily <= dstcapacity)\n\n\n\n\n\n","category":"method"},{"location":"#CodecLz4.LZ4_decompress_safe_continue-Tuple{Ptr{CodecLz4.LZ4_streamDecode_t}, Vararg{Any, 4}}","page":"Home","title":"CodecLz4.LZ4_decompress_safe_continue","text":"LZ4_decompress_safe_continue(streamptr, src, dst, srcsize, dstcapacity)\n\nThese decoding functions allow decompression of consecutive blocks in \"streaming\" mode. A block is an unsplittable entity, it must be presented entirely to a decompression function. Decompression functions only accept one block at a time. Previously decoded blocks must remain available at the memory position where they were decoded (up to 64 KB).\n\nSpecial : if application sets a ring buffer for decompression, it must respect one of the following conditions :\n\nExactly same size as encoding buffer, with same update rule (block boundaries at same positions) In which case, the decoding & encoding ring buffer can have any size, including very small ones ( < 64 KB).\nLarger than encoding buffer, by a minimum of maxBlockSize more bytes. maxBlockSize is implementation dependent. It's the maximum size of any single block. In which case, encoding and decoding buffers do not need to be synchronized, and encoding ring buffer can have any size, including small ones ( < 64 KB).\nAt least 64 KB + 8 bytes + maxBlockSize. In which case, encoding and decoding buffers do not need to be synchronized, and encoding ring buffer can have any size, including larger than decoding buffer.\n\nWhenever these conditions are not possible, save the last 64KB of decoded data into a safe buffer, and indicate where it is saved using LZ4_setStreamDecode() before decompressing next block.\n\n\n\n\n\n","category":"method"},{"location":"#CodecLz4.LZ4_freeStream-Tuple{Ptr{CodecLz4.LZ4_stream_t}}","page":"Home","title":"CodecLz4.LZ4_freeStream","text":"LZ4_freeStream(streamptr::Ptr{LZ4_stream_t})\n\nReleases memory allocated by LZ4_createStream.\n\n\n\n\n\n","category":"method"},{"location":"#CodecLz4.LZ4_freeStreamDecode-Tuple{Ptr{CodecLz4.LZ4_streamDecode_t}}","page":"Home","title":"CodecLz4.LZ4_freeStreamDecode","text":"LZ4_freeStreamDecode(streamptr)\n\nThese decoding functions work the same as creation / destruction of streaming decompression tracking structure. A tracking structure can be re-used multiple times sequentially.\n\n\n\n\n\n","category":"method"},{"location":"#CodecLz4.LZ4_freeStreamHC-Tuple{Ptr{CodecLz4.LZ4_streamHC_t}}","page":"Home","title":"CodecLz4.LZ4_freeStreamHC","text":"LZ4_freeStreamHC(streamptr)\n\nRelease memory for LZ4 HC streaming state. Existing states can be re-used several times, using LZ4_resetStreamHC().\n\n\n\n\n\n","category":"method"},{"location":"#CodecLz4.LZ4_resetStream-Tuple{Ptr{CodecLz4.LZ4_stream_t}}","page":"Home","title":"CodecLz4.LZ4_resetStream","text":"LZ4_resetStream(streamptr)\n\nAn LZ4streamt structure can be allocated once and re-used multiple times. Use this function to start compressing a new stream.\n\n\n\n\n\n","category":"method"},{"location":"#CodecLz4.LZ4_setStreamDecode","page":"Home","title":"CodecLz4.LZ4_setStreamDecode","text":"LZ4_setStreamDecode(streamptr, dictionary, dictsize)\n\nAn LZ4streamDecodet structure can be allocated once and re-used multiple times. Use this function to start decompression of a new stream of blocks. A dictionary can optionally be set. Use NULL or size 0 for a simple reset order. Returns 1 if OK\n\n\n\n\n\n","category":"function"},{"location":"#CodecLz4.lz4_compress","page":"Home","title":"CodecLz4.lz4_compress","text":"lz4_compress(input::Union{Vector{UInt8},Base.CodeUnits{UInt8}}, acceleration::Integer=0)\n\nCompresses input using LZ4compressfast. Returns a Vector{UInt8} of the compressed data.\n\n\n\n\n\n","category":"function"},{"location":"#CodecLz4.lz4_decompress","page":"Home","title":"CodecLz4.lz4_decompress","text":"lz4_decompress(input::Union{Vector{UInt8},Base.CodeUnits{UInt8}}, expected_size::Integer=input.size * 2)\n\nDecompresses input using LZ4decompresssafe. expected_size must be equal to or larger than the expected decompressed size of the input or decompression will fail. Returns a Vector{UInt8} of the decompressed data.\n\n\n\n\n\n","category":"function"},{"location":"#CodecLz4.lz4_hc_compress","page":"Home","title":"CodecLz4.lz4_hc_compress","text":"lz4_hc_compress(input::Union{Vector{UInt8},Base.CodeUnits{UInt8}}, acceleration::Integer=9)\n\nCompresses input using LZ4compressHC. Returns a Vector{UInt8} of the compressed data.\n\n\n\n\n\n","category":"function"},{"location":"#TranscodingStreams.expectedsize-Tuple{LZ4FastCompressor, TranscodingStreams.Memory}","page":"Home","title":"TranscodingStreams.expectedsize","text":"TranscodingStreams.expectedsize(codec::Union{LZ4FastCompressor, LZ4HCCompressor}, input::Memory)\n\nReturns the expected size of the transcoded data.\n\n\n\n\n\n","category":"method"},{"location":"#TranscodingStreams.expectedsize-Tuple{LZ4FrameCompressor, TranscodingStreams.Memory}","page":"Home","title":"TranscodingStreams.expectedsize","text":"TranscodingStreams.expectedsize(codec::LZ4FrameCompressor, input::Memory)\n\nReturns the expected size of the transcoded data.\n\n\n\n\n\n","category":"method"},{"location":"#TranscodingStreams.expectedsize-Tuple{LZ4HCCompressor, TranscodingStreams.Memory}","page":"Home","title":"TranscodingStreams.expectedsize","text":"TranscodingStreams.expectedsize(codec::Union{LZ4FastCompressor, LZ4HCCompressor}, input::Memory)\n\nReturns the expected size of the transcoded data.\n\n\n\n\n\n","category":"method"},{"location":"#TranscodingStreams.expectedsize-Tuple{LZ4SafeDecompressor, TranscodingStreams.Memory}","page":"Home","title":"TranscodingStreams.expectedsize","text":"TranscodingStreams.expectedsize(codec::LZ4SafeDecompressor, input::Memory)\n\nReturns the expected size of the transcoded data.\n\n\n\n\n\n","category":"method"},{"location":"#TranscodingStreams.finalize-Tuple{LZ4FastCompressor}","page":"Home","title":"TranscodingStreams.finalize","text":"TranscodingStreams.finalize(codec::LZ4FastCompressor)\n\nFinalizes the LZ4 Compression Codec.\n\n\n\n\n\n","category":"method"},{"location":"#TranscodingStreams.finalize-Tuple{LZ4FrameCompressor}","page":"Home","title":"TranscodingStreams.finalize","text":"TranscodingStreams.finalize(codec::LZ4FrameCompressor)\n\nFinalizes the LZ4F Compression Codec.\n\n\n\n\n\n","category":"method"},{"location":"#TranscodingStreams.finalize-Tuple{LZ4FrameDecompressor}","page":"Home","title":"TranscodingStreams.finalize","text":"TranscodingStreams.finalize(codec::LZ4FrameDecompressor)\n\nFinalizes the LZ4F Decompression Codec.\n\n\n\n\n\n","category":"method"},{"location":"#TranscodingStreams.finalize-Tuple{LZ4HCCompressor}","page":"Home","title":"TranscodingStreams.finalize","text":"TranscodingStreams.finalize(codec::LZ4HCCompressor)\n\nFinalizes the LZHC Compression Codec.\n\n\n\n\n\n","category":"method"},{"location":"#TranscodingStreams.finalize-Tuple{LZ4SafeDecompressor}","page":"Home","title":"TranscodingStreams.finalize","text":"TranscodingStreams.finalize(codec::LZ4SafeDecompressor)\n\nFinalizes the LZ4SafeDecompression Codec.\n\n\n\n\n\n","category":"method"},{"location":"#TranscodingStreams.initialize-Tuple{LZ4FastCompressor}","page":"Home","title":"TranscodingStreams.initialize","text":"TranscodingStreams.initialize(codec::LZ4FastCompressor)\n\nInitializes the LZ4 Compression Codec.\n\n\n\n\n\n","category":"method"},{"location":"#TranscodingStreams.initialize-Tuple{LZ4FrameCompressor}","page":"Home","title":"TranscodingStreams.initialize","text":"TranscodingStreams.initialize(codec::LZ4FrameCompressor)\n\nInitializes the LZ4F Compression Codec.\n\n\n\n\n\n","category":"method"},{"location":"#TranscodingStreams.initialize-Tuple{LZ4FrameDecompressor}","page":"Home","title":"TranscodingStreams.initialize","text":"TranscodingStreams.initialize(codec::LZ4FrameDecompressor)\n\nInitializes the LZ4F Decompression Codec.\n\n\n\n\n\n","category":"method"},{"location":"#TranscodingStreams.initialize-Tuple{LZ4HCCompressor}","page":"Home","title":"TranscodingStreams.initialize","text":"TranscodingStreams.initialize(codec::LZ4HCCompressor)\n\nInitializes the LZ4 HC compression Codec.\n\n\n\n\n\n","category":"method"},{"location":"#TranscodingStreams.initialize-Tuple{LZ4SafeDecompressor}","page":"Home","title":"TranscodingStreams.initialize","text":"TranscodingStreams.initialize(codec::LZ4SafeDecompressor)\n\nInitializes the LZ4 Compression Codec.\n\n\n\n\n\n","category":"method"},{"location":"#TranscodingStreams.minoutsize-Tuple{LZ4FastCompressor, TranscodingStreams.Memory}","page":"Home","title":"TranscodingStreams.minoutsize","text":"TranscodingStreams.minoutsize(codec::Union{LZ4FastCompressor, LZ4HCCompressor}, input::Memory)\n\nReturns the minimum output size of process.\n\n\n\n\n\n","category":"method"},{"location":"#TranscodingStreams.minoutsize-Tuple{LZ4FrameCompressor, TranscodingStreams.Memory}","page":"Home","title":"TranscodingStreams.minoutsize","text":"TranscodingStreams.minoutsize(codec::LZ4FrameCompressor, input::Memory)\n\nReturns the minimum output size of process.\n\n\n\n\n\n","category":"method"},{"location":"#TranscodingStreams.minoutsize-Tuple{LZ4HCCompressor, TranscodingStreams.Memory}","page":"Home","title":"TranscodingStreams.minoutsize","text":"TranscodingStreams.minoutsize(codec::Union{LZ4FastCompressor, LZ4HCCompressor}, input::Memory)\n\nReturns the minimum output size of process.\n\n\n\n\n\n","category":"method"},{"location":"#TranscodingStreams.minoutsize-Tuple{LZ4SafeDecompressor, TranscodingStreams.Memory}","page":"Home","title":"TranscodingStreams.minoutsize","text":"TranscodingStreams.minoutsize(codec::LZ4SafeDecompressor, input::Memory)\n\nReturns the minimum output size of process.\n\n\n\n\n\n","category":"method"},{"location":"#TranscodingStreams.process-Tuple{LZ4FastCompressor, TranscodingStreams.Memory, TranscodingStreams.Memory, TranscodingStreams.Error}","page":"Home","title":"TranscodingStreams.process","text":"TranscodingStreams.process(codec::LZ4FastCompressor, input::Memory, output::Memory, error::Error)\n\nCompresses the data from input and writes to output. The process follows the compression example from https://github.com/lz4/lz4/blob/dev/examples/blockStreaming_doubleBuffer.c wherein each block of encoded data is prefixed by the number of bytes contained in that block. Decoding can be done through the LZ4SafeDecompressor.\n\n\n\n\n\n","category":"method"},{"location":"#TranscodingStreams.process-Tuple{LZ4FrameCompressor, TranscodingStreams.Memory, TranscodingStreams.Memory, TranscodingStreams.Error}","page":"Home","title":"TranscodingStreams.process","text":"TranscodingStreams.process(codec::LZ4FrameCompressor, input::Memory, output::Memory, error::Error)\n\nCompresses the data from input and writes to output. The LZ4 compression algorithm may simply buffer the input data a full frame can be produced, so data_written may be 0. flush() may be used to force output to be written.\n\n\n\n\n\n","category":"method"},{"location":"#TranscodingStreams.process-Tuple{LZ4FrameDecompressor, TranscodingStreams.Memory, TranscodingStreams.Memory, TranscodingStreams.Error}","page":"Home","title":"TranscodingStreams.process","text":"TranscodingStreams.process(codec::LZ4FrameDecompressor, input::Memory, output::Memory, error::Error)\n\nDecompresses the data from input and writes to output. If the input data is not properly formatted this function will throw an error.\n\n\n\n\n\n","category":"method"},{"location":"#TranscodingStreams.process-Tuple{LZ4HCCompressor, TranscodingStreams.Memory, TranscodingStreams.Memory, TranscodingStreams.Error}","page":"Home","title":"TranscodingStreams.process","text":"TranscodingStreams.process(codec::LZ4HCCompressor, input::Memory, output::Memory, error::Error)\n\nCompresses the data from input and writes to output. The process follows the compression example from https://github.com/lz4/lz4/blob/dev/examples/HCStreaming_ringBuffer.c wherein each block of encoded data is prefixed by the number of bytes contained in that block. Decoding can be done through the LZ4SafeDecompressor.\n\n\n\n\n\n","category":"method"},{"location":"#TranscodingStreams.process-Tuple{LZ4SafeDecompressor, TranscodingStreams.Memory, TranscodingStreams.Memory, TranscodingStreams.Error}","page":"Home","title":"TranscodingStreams.process","text":"TranscodingStreams.process(codec::LZ4SafeDecompressor, input::Memory, output::Memory, error::Error)\n\nCompresses the data from input and writes to output. The process follows the decompression example from https://github.com/lz4/lz4/blob/dev/examples/blockStreaming_doubleBuffer.c and requires each block of encoded data to be prefixed by the number of bytes contained in that block.\n\n\n\n\n\n","category":"method"},{"location":"#TranscodingStreams.startproc-Tuple{LZ4FastCompressor, Symbol, TranscodingStreams.Error}","page":"Home","title":"TranscodingStreams.startproc","text":"TranscodingStreams.startproc(codec::LZ4FastCompressor, mode::Symbol, error::Error)\n\nStarts processing with the codec\n\n\n\n\n\n","category":"method"},{"location":"#TranscodingStreams.startproc-Tuple{LZ4FrameCompressor, Symbol, TranscodingStreams.Error}","page":"Home","title":"TranscodingStreams.startproc","text":"TranscodingStreams.startproc(codec::LZ4FrameCompressor, mode::Symbol, error::Error)\n\nStarts processing with the codec Creates the LZ4F header to be written to the output.\n\n\n\n\n\n","category":"method"},{"location":"#TranscodingStreams.startproc-Tuple{LZ4HCCompressor, Symbol, TranscodingStreams.Error}","page":"Home","title":"TranscodingStreams.startproc","text":"TranscodingStreams.startproc(codec::LZ4HCCompressor, mode::Symbol, error::Error)\n\nStarts processing with the codec\n\n\n\n\n\n","category":"method"},{"location":"#TranscodingStreams.startproc-Tuple{LZ4SafeDecompressor, Symbol, TranscodingStreams.Error}","page":"Home","title":"TranscodingStreams.startproc","text":"TranscodingStreams.startproc(codec::LZ4SafeDecompressor, mode::Symbol, error::Error)\n\nStarts processing with the codec\n\n\n\n\n\n","category":"method"}]
}
